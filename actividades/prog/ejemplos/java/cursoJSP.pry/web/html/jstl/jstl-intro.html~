<html>
	<head><title>Curso JSP (Java Server Pages)</title></head>
<body bgcolor=#ffffff>
 
        <a href="../jstl.html">JSTL</a> 



<h2>El Lenguaje de Expresión JSTL</h2>
<ul>
<li>JSTL define un Lenguaje de Expresiones (EL).</li>
<li>EL es un lenguaje para acceder a datos de varias fuentes en tiempo de ejecución.</li>
<li>Sintaxis es considerablemente más amigable que la de Java.</li>
<li>EL toma prestada de JavaScript la sintaxis para acceder a datos.</li>
<li>Ejemplos operadores de propiedad y elemento array</li>
<blockquote><pre>
${myObj.myProperty}$
${myObj["myProperty"]}$
${myObj[varWithTheName]}$
${myList[2]}$
${myList[aVar + 1]}$
</pre></blockquote>
<li>Expresión EL debe estar encerrada entre los caracteres ${ y }$.</li>

<li>Operadores aritméticos, relacionales, y lógicos, comprobar si un objeto está "vacío" o no puede ser usado en una expresión EL.</li>
</ul>

<h2>Lista de operadores</h2>
<ul>
<li>. Accede a una propiedad</li>
<li>[] Accede a un elemento de un array/lista</li>
<li>() Agrupa una subexpression</li>
<li>+ Suma</li>
<li>- Resta o negación de un número</li>
<li>/ o div División</li>
<li>% o mod Módulo (resto)</li>
<li>== o eq Comprueba Igualdad</li>
<li>!= o ne Comprueba desigualdad</li>
<li>&lt; o lt Comprueba menor que</li>
<li>&gt; o gt Comprueba mayor que</li>
<li>&lt;= o le Comprueba menor o igual que</li> 
<li>&gt;= o gt Comprueba mayor o igual que</li>
<li>&& o and Comrpueba AND lógico</li>
<li>|| o or Comprueba OR lógico</li>
<li>! o not Complemento binario booleano</li>
<li>empty Comprueba un valor vacío (null, string vacío, o una collección vacía)</li>
</ul>

<li>No encontraremos en EL sentencias como asignaciones, if/else, o while.</li>
<li>Tipo de Literal Descripción: String Encerrado con comillas simples o dobles.</li>
<li>Cualquier objeto en uno de los ámbitos de JSP (página, solicitud, sesión o aplicación) se puede utilizar como una variable en una expresión EL.</li>
</ul>


<h2>Variable Descripción</h2>
<ul>
	<li>param Una collection de todos de los parámetros de la solicitud</li>
	<li>paramValues Una collection de todos los valores de los parámetros de la solicitud</li>
	<li>header Una collection de todas las cabeceras de solicitud</li>
	<li>headerValues Una collection de todos los valores de cabecera de la solicitud</li>
	<li>cookie Una collection con todas las cookies de la solicitud</li>
	<li>initParams Una collection de todos los parámetros de inicialización de la aplicación.</li>
	<li>pageContext Un ejemplar de la clase javax.servlet.jspPageContext. </li>
	<li>pageScope Una collection de todos los objetos en el ámbito de la página.</li>
	<li>requestScope Una collection de todos los objetos en el ámbito de la solicitud.</li>
	<li>sessionScope Una collection de todos los objetos en el ámbito de la sesión.</li>
	<li>applicationScope Una collection de todos los objetos en el ámbito de la aplicación.</li>
</ul>
<li>Ejemplo de cómo acceder a un parámetro de solicitud llamado listType y a la cabecera User-Agent:</li>
<blockquote><pre>
${param.listType}
${header['User-Agent']}
</pre></blockquote>

<li>La variable initParameter proporciona acceso a los parámetros de inicialización que se definen en el fichero web.xml de la aplicación.</li>
<li>La variable pageContext tiene varias propiedades que proporcionan acceso al objeto servlet que representa la solicitud, la respuesta, la sesión y la aplicación, etc. </li>
<li>Las cuatro últimas variables son colecciones que contienen todos los objetos de cada ámbito específico. Podemos usarlas para limitar la búsqueda de un objeto en sólo un ámbito en lugar de buscar en todos ellos, lo que está por defecto si no se especifica ningún ámbito. En otras palabras, si hay un objeto llamado customer en el ámbito de sesión, estas dos primeras expresiones encuentran el mismo objeto, pero la tercera vuelve vacía:</li>

<blockquote><pre>
${customer}
${sessionScope.customer}
${requestScope.customer}
</pre></blockquote>
<li>Las acciones JSTL aceptan expresiones EL como valores de atributo, para todos los atributos excepto para var y scope.</li> 

<blockquote><pre>
First name: &lt;c:out value="${customer.firstName}" /&gt;
&lt;c:out value="First name: ${customer.firstName}" /&gt;
</pre></blockquote>

<li>Todas las acciones JSTL de la librería EL aceptan expresiones EL. Realmente hay un conjunto parelelo de librerías JSTL, llamado conjunto de librería RT. que sólo acepta expresiones Java del viejo estilo: 
<blockquote><pre>
First name: &lt;c_rt:out value="<%= customer.getFirstName() %>" /&gt; 
</pre></blockquote>
</ul>

<h2>Procesamiento Condicional y Bucles</h2>
<ul>
<li>c:if, c:choose, c:when, c:otherwise, y c:forEach.</li> 
<li>&lt;c:if&gt; procesar condicionalmente una parte de una página.</li>
<blockquote><pre>
&lt;c:if test="${!empty cookie.userName}"&gt;
    Welcome back &lt;c:out value="${cookie.userName.value}" /&gt;
&lt;/c:if&gt; 
</pre></blockquote>

<li>El valor del atributo test es una expresión EL que chequea si la cookie existe.</li>
<li>El operador empty combinado con el operador "not" (!) significa que evalúa a true si el cookie no existe, haciendo que el cuerpo del elemento sea procesado.</li>
<li>Dentro del cuerpo, la acción c:out añade el valor de la cookie a la respuesta.</li>

<li>Este fragmento itera sobre una colección de filas de una base de datos con información del tiempo de diferentes ciudades:</li>
<blockquote><pre>
&lt;c:forEach items="${forecasts.rows}" var="${city}"&gt;
   City: &lt;c:out value="${city.name}" /&gt;
   Tomorrow's high: &lt;c:out value="${city.high}" /&gt;
   Tomorrow's low: &lt;c:out value="${city.low}" /&gt;
   &lt;/c:forEach&gt;
</pre></blockquote>


<li>Procesar sólo un conjunto fijo de filas por cada página solicitada, añadamos enlaces "Previous" y "Next" a la misma página. El usuario puede entonces pasar sobre los resultados de la base de datos, mirando unas pocas fila cada vez:</li>

<blockquote><pre>
<c:set var="noOfRows" value="10" />

<c:forEach items="${forecasts.rows}" var="${city}"
    begin="${param.first}" end="${param.first + noOfRows - 1}">
    City: <c:out value="${city.name}" />
    Tomorrow's high: <c:out value="${city.high}" />
    Tomorrow's low: <c:out value="${city.low}" />
</c:forEach>

<c:choose>
  <c:when test="${param.first > 0}">
     <a href="foreach.jsp?first=<c:out value="${param.first - noOfRows}"/>">Previous Page</a>
  </c:when>
  <c:otherwise>
     Previous Page
  </c:otherwise>
</c:choose>
<c:choose>
  <c:when test="${param.first + noOfRows < forecasts.rowsCount}">
     <a href="foreach.jsp?first=<c:out value="${param.first + noOfRows}"/>">Next Page</a>
  </c:when>
  <c:otherwise>
     Next Page
  </c:otherwise>
  </c:choose>
</pre></blockquote>
</ul>

<h2>Procesar URLs</h2>
<ul>
        <li>Los ejemplos anteriores funcionan bien mientras se utilicen las cookies para seguimiento de sesión. No está todo dado; el navegador podría tener desactivadas las cookies, o no soportarlas. Por lo tanto es una buena idea activar el contenedor para usar la reescritura de URL como backup de los cookies.</li>
        <li>La reescritura de URL, como podrías conocer, significa poner el ID de la sesión en todas las URLs usadas en los enlaces y formularios de la página. Una URL reescrita se parece a algo como esto: <code>myPage.jsp;jspsessionid=ah3bf5e317xmw5</code></li>
        <li>Cuando el usuario pulsa en una línea como esta, el identificador de sesión ID se envía al contenedor como parte de la URL. La librería corazón de JSTL incluye la acción c:url, que tiene cuidado de la reescritura de URL por nosotros. Aquí está como podemos usarla para mejorar la generación del enlace "Previous Page" del ejemplo anterior: </li>

<blockquote><pre>
<c:url var="previous" value="foreach.jsp">
  <c:param name="first" value="${param.first - noOfRows}" />
</c:url>
<a href="<c:out value="${previous}"/>">Previous Page</a>
</pre></blockquote>
<c:url> soporta un atributo var, usado para especificar una variable para contener la URL codificada, y un atributo value para contener la URL a codificar. Se pueden especificar parámetros string para solicitar la URL usando acciones <c:param>. Los caracteres especiales en los parámetros especificados por elementos anidados son codificados (si es necesario) y luego añadidos a la URL como parámetros string de la consulta. El resultado final se pasa a través del proceso de reescritura de URL, añadiendo un ID de sesión si está desactivado el seguimiento de sesión usando cookies. En este ejemplo, se utiliza la URL codificada como un valor de atributo href en un elemento de enlace HTML. 

<c:url> también realiza otro buen servicio. Como podría preocuparte, las URLs relativas en elementos HTML también deben ser relativas a la página que los contiene o al directorio raíz del servidor (si empiezan con una barra inclinada). La primera parte del path de una URL de una página JSP se llama path de contexto, y podría variar de instalación a instalación. Por lo tanto deberíamos evitar codificar el path de contexto en las páginas JSP. Pero algunas veces realmente querremos utilizar un path de URL relativo al servidor en elemento HTML; por ejemplo cuando necesitamos referirnos a un fichero de imagen localizado en el directorio /images compartido por todas las páginas JSP. Las buenas noticias es que si especificamos una URL con un barra inclinada como el valor <c:url>, lo convierte en un path relativo al servidor. Por ejemplo, en una aplicación con el path de contexto /myApp, la acción <c:url> convierte el path a /myApp/images/logo.gif: 

<c:url value="/images/logo.gif" />Hay unas cuantas acciones más relacionadas con las URLs en la librería corazón. La acción <c:import> es una acción más flexible que la acción estándar <jsp:include>. Podemos usarla para incluir contenido desde los recursos dentro de la misma aplicación Web, desde otras aplicaciones Web en el mismo contenedor, o desde otros servidores, usando protocolos como HTTP y FTP. La accion <c:redirect> nos permite redirigir a otro recurso en la misma aplicación Web, en otra aplicación Web o en un servidor diferente. Ambas acciones son fáciles de usar, por eso te dejamos como ejercicio que las práctiques. 

 


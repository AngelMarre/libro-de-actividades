Tutoriales
JSTL 1.0. Estandarizando JSP.
Autor: OnJava (OnJava)
Traductor: Juan Antonio Palos (Ozito)
Acceder a una Base de Datos
Poner un objeto DataSource a Disposición de JSTL
Leer Datos de la Base de Datos
Escribir Datos en la Base de Datos


<h2>Acceder a una Base de Datos</h2>
<ul>
	<li>Inclusión en JSTL de acciones para acceder a bases de datos.</li>
	<ul>
	<li>Recomendable: usar componentes Java puros en una aplicación basada en MVC en lugar de desde página JSP.</li>
	<li>Excepción: aplicaciones simples.</li>.
	<li>Evitar: Sin el soporte de JSTL, estas aplicaciones terminan con el código dentro de scriptles.</li>
	</ul>
<li>Basado en el API JDBC de Java.</li>
<li><code>DataSource</code> proporciona conexiones a una base de datos.</li>
</ul>

<h2>Poner un objeto DataSource a Disposición de JSTL</h2>
<ul>
<li>Opción 1. Se definie un DataSource por defecto con un parámetro de contexto en el fichero web.xml.</li>
<blockquote><pre>
&lt;context-param&gt;
&lt;param-name&gt;
  javax.servlet.jsp.jstl.sql.dataSource
&lt;/param-name&gt;
&lt;param-value&gt;
  jdbc/Production
&lt;/param-value&gt;
&lt;/context-param&gt;
</pre></blockquote>

<li>Opción 2. Clase oyente crea un DataSource y la hace disponible como por defecto para las acciones JSTL usando la clase Config para seleccionar la variable de configuración correspondiente.</li>
<blockquote><pre>
import javax.servlet.*;
import javax.servlet.http.*;
import oracle.jdbc.pool.*;

public class AppListener implements ServletContextListener {

    private OracleConnectionCacheImpl ds =null;

    public void contextInitialized(ServletContextEvent sce){
        ServletContext application =sce.getServletContext();

        try {
            ds = new OracleConnectionCacheImpl();
            ds.setURL("jdbc:oracle:thin:@voyager2:1521:Oracle9i");
            ds.setMaxLimit(20);
            ds.setUser("scott");
            ds.setPassword("tiger");
        }
        catch (Exception e){
            application.log("Failed to create data source:"+ e.getMessage());
        }
        Config.set(application, Config.SQL_DATASOURCE, ds);
    }
...
}
</pre></blockquote>
</li>

<li>Opción 3. Sólo para prototipos, es usar la acción &lt;sql:setDataSource&gt;:</li>
<blockquote><pre>
&lt;sql:setDataSource
url="jdbc:mysql://dbserver/dbname"
driver="org.gjt.mm.mysql.Driver"
user="scott"
password="tiger" /&gt;
</pre></blockquote>
</ul>

<h2>Leer Datos de la Base de Datos</h2>
<ul>
<li>Ejemplo</li>
<blockquote><pre>
&lt;%@ taglib prefix="sql" uri="http://java.sun.com/jstl/sql" %&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;h1&gt;Leyendo de la base de datos&lt;/h1&gt;
  &lt;sql:query var="emps" sql="SELECT * FROM Employee" /&gt;
  ...
&lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>

<li>Primero declarar la librería JSTL usando la directiva taglib.</li>
<li>La acción &lt;sql:query&gt; ejecuta la sentencia SQL SELECT y graba los resultados en "emps".</li>
<li>El resultado se devuelve como un bean del tipo javax.servlet.jsp.jstl.sql.Result con varias propiedades</li>
</ul>


<h2>Propiedad Tipo Java Descripción</h2>
<ul>
<li>rows java.util.SortedMap[] Un array por cada fila</li>
<li>rowsByIndex Object[][] Un array con un array por fila con valores de columna.</li>
<li>columnNames String[] Un array con nombres de columnas</li>
<li>rowCount int El número de filas en el resultado. </li>
<li>limitedByMaxRows boolean true si no se han incluido todas las filas debido a que se ha alcanzado el límite máximo de filas especificado.</li>
</ul>

<h2>Obtener las filas</h2>
<ul>
<li>Ejemplo:</li> 
<blockquote><pre>
&lt;c:set var="noOfRows" value="10" /&gt;

&lt;sql:query var="emps" 
startRow="${param.start}" maxRows="${noOfRows}"&gt;
SELECT * FROM Employee
&lt;/sql:query&gt;

&lt;ul&gt;
&lt;c:forEach items="${emps.rows}" var="${emp}"&gt;
  &lt;li&gt;&lt;c:out value="${emp.name}" /&gt;
  &lt;/c:forEach&gt;
&lt;/ul&gt;  
</pre></blockquote>
</ul>

<li><b>startRow</b> Este valor cambia cuando se pulsa sobre los enlaces Next y Previous.</li>
<li><b>maxRows</b> límita el número total de filas del valor de la variable noOfRows.</li>

<li>Enlaces Next y Previous:<li>
<blockquote><pre>
&lt;c:choose&gt;
&lt;c:when test="${param.start &gt; 0}"&gt;
  &lt;a href="emplist.jsp?start=<c:out 
  value="${param.start - noOfRows}"/>"&gt;Previous Page&lt;/a&gt;
&lt;/c:when&gt;
&lt;c:otherwise&gt;
  Previous Page
&lt;/c:otherwise&gt;
&lt;/c:choose&gt;
&lt;c:choose&gt;
&lt;c:when test="${emps.limitedByMaxRows}"&gt;
  &lt;a href="emplist.jsp?start=&lt;c:out
	value="${param.start + noOfRows}"/&gt;"&gt;Next Page&lt;/a&gt;
&lt;/c:when&gt;
&lt;c:otherwise&gt;
  Next Page
&lt;/c:otherwise&gt;
&lt;/c:choose&gt;
</pre></blockquote>

<li>Si el parámetro de la solicitud start es mayor que cero, la página actual muestra un subconjunto de filas distinto del primero, por eso se añade un enlace Previous.</li>
<li>Si la propiedad limitedByMaxRows del resultado de la consulta es true, significa que se ha truncado el resultado al número de filas mostrado por cada página. De aquí, se genera el enlace Next con valor del parámetro start para el nuevo subconjunto de filas. </li>
</ul>

<h2>Escribir Datos en la Base de Datos</h2>
<ul>
<li>Ejemplo:</li>
<blockquote><pre>
&lt;c:catch var="error"&gt;
&lt;fmt:parseDate var="empDate" value="${param.empDate}" 
  pattern="yyyy-MM-dd" /&gt;
&lt;/c:catch&gt;
&lt;c:if test="${error != null}"&gt;
&lt;jsp:useBean id="empDate" class="java.util.Date" /&gt;
&lt;/c:if&gt;

&lt;sql:update&gt;
INSERT INTO Employee (FirstName, LastName, EmpDate)
  VALUES(?, ?, ?)
&lt;sql:param value="${param.firstName}" /&gt;
&lt;sql:param value="${param.lastName}" /&gt;
&lt;sql:dateParam value="${empDate}" type="date" /&gt;
&lt;/sql:update&gt;
</pre></blockquote>

<li>La acción &lt;c:catch&gt; tiene en cuenta los strings inválidos. Si el valor del parámetro no puede ser interpretado como una fecha se lanza una excepción, que la acción catch captura y graba en la variable especificada. Cuando esto sucede, la condición de comprobación de la acción if se evalúa a true, por lo que fecha de contratación es creada por la acción useBean anidada.</li> 

<li>La acción &lt;sql:update&gt; se puede usar para ejecutar sentencias INSERT, UPDATE, DELETE, asi como sentencias para crear o eliminar objetos en la base de datos, como CREATE TABLE y DROP TABLE.</li>

<li>Las columnas FirstName y LastName son columnas de texto y las aciones sql:param seleccionan sus valores al valor del parámetro de solicitud correspondiente.</li>

<li>La columna EmpDate, es una columna de fecha y debemos usar la variable crada por las acciones fmt:parseDate o jsp:useBean. Segundo, debemos usar la acción <sql:dateParam> para seleccionar el valor.</li>

<li>Hay una acción JSTL más que no hemos descrito hasta ahora: <sql:transaction>. Podemos usarla para agrupar varias acciones update (o incluso query) donde todas ellas se deben ejecutar como parte de la misma transación de la base de datos. El ejemplo estándard es transferir una cantidad de dinero de una cuenta a otra; implementada como una sentencia SQL que elimina el dinero de la primera cuenta y otra sentencia que lo añade a la segunda.</li>


Si encapsulamos todos los accesos a una base de datos en clases Java en lugar de usar las acciones de JSTL, todavía hay una parte de JSTL que nos puede ser útil. Es una clase llamada javax.servlet.jsp.jstl.sql.ResultSupport, con estos dos métodos: 

public static Result toResult(java.sql.ResultSet rs);
public static Result toResult(java.sql.ResultSet rs, int maxRows);
Podemos usar esta clase para convertir un objeto ResultSet estándar JDBC en un objeto Result JSTL antes de reenviarlo a la página JSP para mostrarlo. Las acciones JSTL pueden acceder fácilmente a los datos de un objeto Result, como vimos anteriormente. Otra aproximación, todavía mejor, es pasar el resultado de la consulta a la página JSP como una estructura de datos personalizada, como una List de beans que contienen los datos de cada fila, pero el objeto Result aún es un buen candidato para prototipos y pequeñas aplicaciones. 

 
</ul>
</body>
</html>
